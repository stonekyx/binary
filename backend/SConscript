#!/usr/bin/python

import subprocess
import os

Import('qtEnv')

env = qtEnv.Clone()

# Find header's full path used by compiler, in case of non-standard locations.
def get_elfutils_dir():
    p = subprocess.Popen([env['CC'], '-E', '-'],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=open(os.devnull, 'w'))
    (out,err) = p.communicate('#include <elfutils/libasm.h>')
    if p.wait() == None:
        p.kill()
    path = [x for x in out.split('\n') if x.find('elfutils/libasm.h')!=-1][0].split('"')[1]
    return path[:path.rfind('/')]

env.Append(CPPPATH=[get_elfutils_dir()])

# Check necessary headers and libs
conf = Configure(env)
if not conf.CheckHeader('libelf.h') or not conf.CheckHeader('gelf.h') or not conf.CheckLib('elf'):
    print 'libelf not found!'
    Exit(1)
if not conf.CheckHeader('elfutils/libasm.h') or \
        not conf.CheckHeader('elfutils/libebl.h') or \
        not conf.CheckLib('asm') or \
        not conf.CheckLib('ebl'):
    print 'elfutils not found!'
    Exit(1)
env = conf.Finish()

env.Append(LIBS=['elf', 'asm', 'ebl'])
env.Append(RPATH=[env.LibraryDir('libasm.so')+'/elfutils'],
        LINKFLAGS=['-Wl,--enable-new-dtags']) # Generate RUNPATH

env.EnableQt4Modules([
    'QtCore'
    ])

env.Moc4('File.h')
env.Moc4('Backend.h')

libbackend = env.SharedLibrary(target='backend', source=Glob('*.cpp')+Glob('*.c')+Glob('*.cc'))
Install(env['LOCAL_LIBDIR'], libbackend)

env.TestDir('test', [libbackend])
